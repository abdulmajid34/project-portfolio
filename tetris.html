<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris vs AI - Abdul Majid Portfolio</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow-x: auto;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .game-header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .game-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .game-board {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: start;
        }

        .player-section {
            text-align: center;
        }

        .player-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .tetris-board {
            width: 300px;
            height: 600px;
            border: 3px solid #2c3e50;
            background: #000;
            position: relative;
            margin: 0 auto 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            width: 100%;
            height: 100%;
        }

        .cell {
            border: 1px solid #333;
            width: 100%;
            height: 100%;
        }

        .cell.filled {
            border: 1px solid #fff;
        }

        .cell.I { background: #00f0f0; }
        .cell.O { background: #f0f000; }
        .cell.T { background: #a000f0; }
        .cell.S { background: #00f000; }
        .cell.Z { background: #f00000; }
        .cell.J { background: #0000f0; }
        .cell.L { background: #f0a000; }

        .next-piece {
            width: 120px;
            height: 120px;
            border: 2px solid #dee2e6;
            background: #f8f9fa;
            margin: 0 auto 15px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
        }

        .next-piece .cell {
            border: 1px solid #dee2e6;
        }

        .stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stat-label {
            font-weight: bold;
            color: #495057;
        }

        .stat-value {
            color: #007bff;
            font-weight: bold;
        }

        .controls-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .control-btn {
            padding: 15px;
            border: 2px solid #007bff;
            background: white;
            color: #007bff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }

        .control-btn:hover {
            background: #007bff;
            color: white;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .btn {
            margin: 5px;
            padding: 10px 20px;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            border: none;
            border-radius: 50px;
            padding: 10px 20px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            color: #333;
            text-decoration: none;
        }

        .winner-message {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            display: none;
            text-align: center;
        }

        .winner-message.show {
            display: block;
        }

        .winner-message.player-win {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .winner-message.ai-win {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .game-controls {
            text-align: center;
            margin-bottom: 30px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .level-display {
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            display: inline-block;
            margin: 10px;
        }

        .vs-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .tetris-board {
                width: 250px;
                height: 500px;
            }

            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .vs-indicator {
                font-size: 1.5rem;
            }
        }

        .ai-thinking {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        .ai-thinking.show {
            display: block;
        }

        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
        }

        .pause-overlay.show {
            display: flex;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn">
        <i class="fas fa-arrow-left"></i> Back to Portfolio
    </a>

    <div class="container game-container">
        <div class="game-header">
            <h1><i class="fas fa-th-large"></i> Tetris vs AI</h1>
            <p>Compete against the AI in classic Tetris! Clear lines faster to win!</p>
        </div>

        <div class="game-board">
            <div class="game-controls">
                <button class="btn btn-success" onclick="startGame()" id="startBtn">
                    <i class="fas fa-play"></i> Start Game
                </button>
                <button class="btn btn-warning" onclick="pauseGame()" id="pauseBtn" disabled>
                    <i class="fas fa-pause"></i> Pause
                </button>
                <button class="btn btn-danger" onclick="resetGame()">
                    <i class="fas fa-stop"></i> Reset
                </button>

                <div class="speed-control">
                    <label>Difficulty:</label>
                    <select id="difficultySelect" class="form-select d-inline-block w-auto">
                        <option value="1">Easy (Level 1)</option>
                        <option value="3" selected>Medium (Level 3)</option>
                        <option value="5">Hard (Level 5)</option>
                        <option value="8">Expert (Level 8)</option>
                    </select>
                </div>
            </div>

            <div class="game-area">
                <!-- Player Section -->
                <div class="player-section">
                    <div class="player-title">You</div>
                    <div class="level-display">Level: <span id="playerLevel">1</span></div>

                    <div class="tetris-board">
                        <div class="grid" id="playerGrid"></div>
                        <div class="pause-overlay" id="playerPause">PAUSED</div>
                    </div>

                    <div class="stats">
                        <div class="stat-item">
                            <span class="stat-label">Score:</span>
                            <span class="stat-value" id="playerScore">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Lines:</span>
                            <span class="stat-value" id="playerLines">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Pieces:</span>
                            <span class="stat-value" id="playerPieces">0</span>
                        </div>
                    </div>

                    <div>
                        <strong>Next Piece:</strong>
                        <div class="next-piece" id="playerNext"></div>
                    </div>

                    <div class="controls-section">
                        <div class="controls-grid">
                            <button class="control-btn" onclick="rotatePiece()">
                                <i class="fas fa-redo"></i>
                            </button>
                            <button class="control-btn" onclick="movePiece(0, -1)">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button class="control-btn" onclick="hardDrop()">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button class="control-btn" onclick="movePiece(-1, 0)">
                                <i class="fas fa-arrow-left"></i>
                            </button>
                            <button class="control-btn" onclick="movePiece(0, 1)">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button class="control-btn" onclick="movePiece(1, 0)">
                                <i class="fas fa-arrow-right"></i>
                            </button>
                        </div>
                        <small>Use WASD or Arrow Keys</small>
                    </div>
                </div>

                <!-- VS Indicator -->
                <div class="vs-indicator">
                    <div style="text-align: center;">
                        <div>VS</div>
                        <div style="font-size: 1rem; margin-top: 10px;">
                            <div id="gameTimer">00:00</div>
                        </div>
                    </div>
                </div>

                <!-- AI Section -->
                <div class="player-section">
                    <div class="player-title">AI Opponent</div>
                    <div class="level-display">Level: <span id="aiLevel">1</span></div>

                    <div class="tetris-board">
                        <div class="grid" id="aiGrid"></div>
                        <div class="pause-overlay" id="aiPause">PAUSED</div>
                    </div>

                    <div class="stats">
                        <div class="stat-item">
                            <span class="stat-label">Score:</span>
                            <span class="stat-value" id="aiScore">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Lines:</span>
                            <span class="stat-value" id="aiLines">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Pieces:</span>
                            <span class="stat-value" id="aiPieces">0</span>
                        </div>
                    </div>

                    <div>
                        <strong>Next Piece:</strong>
                        <div class="next-piece" id="aiNext"></div>
                    </div>

                    <div class="ai-thinking" id="aiThinking">
                        <i class="fas fa-cog fa-spin"></i> AI is thinking...
                    </div>
                </div>
            </div>

            <div class="winner-message" id="winnerMessage"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Game state
        let gameActive = false;
        let gamePaused = false;
        let gameStartTime = null;
        let gameTimer = null;

        // Player state
        let playerBoard = Array(20).fill().map(() => Array(10).fill(0));
        let playerPiece = null;
        let playerPiecePos = {x: 0, y: 0};
        let playerScore = 0;
        let playerLines = 0;
        let playerLevel = 1;
        let playerPieceCount = 0;
        let playerNextPiece = null;
        let playerDropTimer = null;

        // AI state
        let aiBoard = Array(20).fill().map(() => Array(10).fill(0));
        let aiPiece = null;
        let aiPiecePos = {x: 0, y: 0};
        let aiScore = 0;
        let aiLines = 0;
        let aiLevel = 1;
        let aiPieceCount = 0;
        let aiNextPiece = null;
        let aiDropTimer = null;

        // Tetris pieces
        const pieces = {
            I: {
                shape: [[1,1,1,1]],
                color: 'I'
            },
            O: {
                shape: [[1,1],[1,1]],
                color: 'O'
            },
            T: {
                shape: [[0,1,0],[1,1,1]],
                color: 'T'
            },
            S: {
                shape: [[0,1,1],[1,1,0]],
                color: 'S'
            },
            Z: {
                shape: [[1,1,0],[0,1,1]],
                color: 'Z'
            },
            J: {
                shape: [[1,0,0],[1,1,1]],
                color: 'J'
            },
            L: {
                shape: [[0,0,1],[1,1,1]],
                color: 'L'
            }
        };

        const pieceTypes = Object.keys(pieces);

        function createGrid(containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    container.appendChild(cell);
                }
            }
        }

        function getRandomPiece() {
            const type = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
            return {
                type: type,
                shape: pieces[type].shape,
                color: pieces[type].color,
                rotation: 0
            };
        }

        function drawBoard(board, containerId, currentPiece = null, piecePos = null) {
            const container = document.getElementById(containerId);
            const cells = container.querySelectorAll('.cell');

            // Clear all cells
            cells.forEach(cell => {
                cell.className = 'cell';
            });

            // Draw board
            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = cells[row * 10 + col];
                    if (board[row][col]) {
                        cell.classList.add('filled', board[row][col]);
                    }
                }
            }

            // Draw current piece
            if (currentPiece && piecePos) {
                drawPiece(currentPiece, piecePos, containerId);
            }
        }

        function drawPiece(piece, pos, containerId) {
            const container = document.getElementById(containerId);
            const cells = container.querySelectorAll('.cell');

            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardRow = pos.y + row;
                        const boardCol = pos.x + col;

                        if (boardRow >= 0 && boardRow < 20 && boardCol >= 0 && boardCol < 10) {
                            const cellIndex = boardRow * 10 + boardCol;
                            if (cells[cellIndex]) {
                                cells[cellIndex].classList.add('filled', piece.color);
                            }
                        }
                    }
                }
            }
        }

        function drawNextPiece(piece, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    container.appendChild(cell);
                }
            }

            if (piece) {
                const cells = container.querySelectorAll('.cell');
                const offsetX = Math.floor((4 - piece.shape[0].length) / 2);
                const offsetY = Math.floor((4 - piece.shape.length) / 2);

                for (let row = 0; row < piece.shape.length; row++) {
                    for (let col = 0; col < piece.shape[row].length; col++) {
                        if (piece.shape[row][col]) {
                            const cellRow = offsetY + row;
                            const cellCol = offsetX + col;
                            const cellIndex = cellRow * 4 + cellCol;

                            if (cells[cellIndex]) {
                                cells[cellIndex].classList.add('filled', piece.color);
                            }
                        }
                    }
                }
            }
        }

        function canPlacePiece(board, piece, pos) {
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardRow = pos.y + row;
                        const boardCol = pos.x + col;

                        if (boardRow < 0 || boardRow >= 20 || boardCol < 0 || boardCol >= 10) {
                            return false;
                        }

                        if (board[boardRow][boardCol]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placePiece(board, piece, pos) {
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardRow = pos.y + row;
                        const boardCol = pos.x + col;
                        board[boardRow][boardCol] = piece.color;
                    }
                }
            }
        }

        function clearLines(board) {
            let linesCleared = 0;

            for (let row = 19; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                    board.splice(row, 1);
                    board.unshift(Array(10).fill(0));
                    linesCleared++;
                    row++; // Check same row again
                }
            }

            return linesCleared;
        }

        function rotatePiece() {
            if (!gameActive || gamePaused || !playerPiece) return;

            const rotated = rotatePieceMatrix(playerPiece.shape);
            const newPiece = {...playerPiece, shape: rotated};

            if (canPlacePiece(playerBoard, newPiece, playerPiecePos)) {
                playerPiece = newPiece;
                drawBoard(playerBoard, 'playerGrid', playerPiece, playerPiecePos);
            }
        }

        function rotatePieceMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = Array(cols).fill().map(() => Array(rows).fill(0));

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    rotated[col][rows - 1 - row] = matrix[row][col];
                }
            }

            return rotated;
        }

        function movePiece(dx, dy) {
            if (!gameActive || gamePaused || !playerPiece) return;

            const newPos = {x: playerPiecePos.x + dx, y: playerPiecePos.y + dy};

            if (canPlacePiece(playerBoard, playerPiece, newPos)) {
                playerPiecePos = newPos;
                drawBoard(playerBoard, 'playerGrid', playerPiece, playerPiecePos);
            } else if (dy > 0) {
                // Piece can't move down, place it
                placePiece(playerBoard, playerPiece, playerPiecePos);
                const linesCleared = clearLines(playerBoard);
                updatePlayerScore(linesCleared);
                spawnPlayerPiece();
            }
        }

        function hardDrop() {
            if (!gameActive || gamePaused || !playerPiece) return;

            while (canPlacePiece(playerBoard, playerPiece, {x: playerPiecePos.x, y: playerPiecePos.y + 1})) {
                playerPiecePos.y++;
            }

            placePiece(playerBoard, playerPiece, playerPiecePos);
            const linesCleared = clearLines(playerBoard);
            updatePlayerScore(linesCleared);
            spawnPlayerPiece();
        }

        function spawnPlayerPiece() {
            playerPiece = playerNextPiece || getRandomPiece();
            playerNextPiece = getRandomPiece();
            playerPiecePos = {x: 4, y: 0};
            playerPieceCount++;

            if (!canPlacePiece(playerBoard, playerPiece, playerPiecePos)) {
                endGame('ai');
                return;
            }

            drawBoard(playerBoard, 'playerGrid', playerPiece, playerPiecePos);
            drawNextPiece(playerNextPiece, 'playerNext');
            updatePlayerDisplay();
        }

        function updatePlayerScore(linesCleared) {
            if (linesCleared > 0) {
                playerLines += linesCleared;
                playerScore += linesCleared * 100 * playerLevel;
                playerLevel = Math.floor(playerLines / 10) + 1;

                // Speed up game
                if (playerDropTimer) {
                    clearInterval(playerDropTimer);
                    startPlayerDropTimer();
                }
            }
            updatePlayerDisplay();
        }

        function updatePlayerDisplay() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('playerLines').textContent = playerLines;
            document.getElementById('playerLevel').textContent = playerLevel;
            document.getElementById('playerPieces').textContent = playerPieceCount;
        }

        function startPlayerDropTimer() {
            const speed = Math.max(100, 1000 - (playerLevel * 100));
            playerDropTimer = setInterval(() => {
                if (gameActive && !gamePaused) {
                    movePiece(0, 1);
                }
            }, speed);
        }

        // AI Logic
        function aiMove() {
            if (!gameActive || gamePaused || !aiPiece) return;

            document.getElementById('aiThinking').classList.add('show');

            setTimeout(() => {
                const bestMove = findBestAIMove();
                executeAIMove(bestMove);
                document.getElementById('aiThinking').classList.remove('show');
            }, 200 + Math.random() * 300); // Simulate thinking time
        }

        function findBestAIMove() {
            let bestScore = -Infinity;
            let bestMove = null;

            // Try all possible positions and rotations
            for (let rotation = 0; rotation < 4; rotation++) {
                let testPiece = {...aiPiece};

                // Rotate piece
                for (let r = 0; r < rotation; r++) {
                    testPiece.shape = rotatePieceMatrix(testPiece.shape);
                }

                // Try all horizontal positions
                for (let x = -2; x < 12; x++) {
                    // Find lowest valid position
                    let y = 0;
                    while (y < 20 && canPlacePiece(aiBoard, testPiece, {x, y})) {
                        y++;
                    }
                    y--; // Last valid position

                    if (y >= 0 && canPlacePiece(aiBoard, testPiece, {x, y})) {
                        const score = evaluateAIMove(testPiece, {x, y});
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = {piece: testPiece, pos: {x, y}, rotations: rotation};
                        }
                    }
                }
            }

            return bestMove;
        }

        function evaluateAIMove(piece, pos) {
            // Create a copy of the board
            const testBoard = aiBoard.map(row => [...row]);

            // Place the piece
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardRow = pos.y + row;
                        const boardCol = pos.x + col;
                        if (boardRow >= 0 && boardRow < 20 && boardCol >= 0 && boardCol < 10) {
                            testBoard[boardRow][boardCol] = piece.color;
                        }
                    }
                }
            }

            // Count lines that would be cleared
            let linesCleared = 0;
            for (let row = 0; row < 20; row++) {
                if (testBoard[row].every(cell => cell !== 0)) {
                    linesCleared++;
                }
            }

            // Calculate score
            let score = linesCleared * 1000; // Lines are very valuable

            // Penalize height
            for (let col = 0; col < 10; col++) {
                for (let row = 0; row < 20; row++) {
                    if (testBoard[row][col]) {
                        score -= (20 - row) * 5;
                        break;
                    }
                }
            }

            // Penalize holes
            for (let col = 0; col < 10; col++) {
                let foundBlock = false;
                for (let row = 0; row < 20; row++) {
                    if (testBoard[row][col]) {
                        foundBlock = true;
                    } else if (foundBlock) {
                        score -= 100; // Big penalty for holes
                    }
                }
            }

            return score;
        }

        function executeAIMove(move) {
            if (!move) return;

            // Apply rotations
            aiPiece = move.piece;
            aiPiecePos = move.pos;

            // Place the piece
            placePiece(aiBoard, aiPiece, aiPiecePos);
            const linesCleared = clearLines(aiBoard);
            updateAIScore(linesCleared);
            spawnAIPiece();
        }

        function spawnAIPiece() {
            aiPiece = aiNextPiece || getRandomPiece();
            aiNextPiece = getRandomPiece();
            aiPiecePos = {x: 4, y: 0};
            aiPieceCount++;

            if (!canPlacePiece(aiBoard, aiPiece, aiPiecePos)) {
                endGame('player');
                return;
            }

            drawBoard(aiBoard, 'aiGrid', aiPiece, aiPiecePos);
            drawNextPiece(aiNextPiece, 'aiNext');
            updateAIDisplay();
        }

        function updateAIScore(linesCleared) {
            if (linesCleared > 0) {
                aiLines += linesCleared;
                aiScore += linesCleared * 100 * aiLevel;
                aiLevel = Math.floor(aiLines / 10) + 1;

                // Speed up AI
                if (aiDropTimer) {
                    clearInterval(aiDropTimer);
                    startAIDropTimer();
                }
            }
            updateAIDisplay();
        }

        function updateAIDisplay() {
            document.getElementById('aiScore').textContent = aiScore;
            document.getElementById('aiLines').textContent = aiLines;
            document.getElementById('aiLevel').textContent = aiLevel;
            document.getElementById('aiPieces').textContent = aiPieceCount;
        }

        function startAIDropTimer() {
            const difficulty = parseInt(document.getElementById('difficultySelect').value);
            const speed = Math.max(200, 1200 - (aiLevel * 100) - (difficulty * 50));

            aiDropTimer = setInterval(() => {
                if (gameActive && !gamePaused) {
                    aiMove();
                }
            }, speed);
        }

        function startGame() {
            gameActive = true;
            gamePaused = false;
            gameStartTime = Date.now();

            // Reset everything
            playerBoard = Array(20).fill().map(() => Array(10).fill(0));
            aiBoard = Array(20).fill().map(() => Array(10).fill(0));
            playerScore = 0;
            playerLines = 0;
            playerLevel = parseInt(document.getElementById('difficultySelect').value);
            playerPieceCount = 0;
            aiScore = 0;
            aiLines = 0;
            aiLevel = parseInt(document.getElementById('difficultySelect').value);
            aiPieceCount = 0;

            // UI updates
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('winnerMessage').classList.remove('show');

            // Spawn first pieces
            spawnPlayerPiece();
            spawnAIPiece();

            // Start timers
            startPlayerDropTimer();
            startAIDropTimer();
            startGameTimer();

            updatePlayerDisplay();
            updateAIDisplay();
        }

        function pauseGame() {
            gamePaused = !gamePaused;

            if (gamePaused) {
                document.getElementById('pauseBtn').innerHTML = '<i class="fas fa-play"></i> Resume';
                document.getElementById('playerPause').classList.add('show');
                document.getElementById('aiPause').classList.add('show');
            } else {
                document.getElementById('pauseBtn').innerHTML = '<i class="fas fa-pause"></i> Pause';
                document.getElementById('playerPause').classList.remove('show');
                document.getElementById('aiPause').classList.remove('show');
            }
        }

        function resetGame() {
            gameActive = false;
            gamePaused = false;

            // Clear timers
            if (playerDropTimer) clearInterval(playerDropTimer);
            if (aiDropTimer) clearInterval(aiDropTimer);
            if (gameTimer) clearInterval(gameTimer);

            // Reset UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').innerHTML = '<i class="fas fa-pause"></i> Pause';
            document.getElementById('playerPause').classList.remove('show');
            document.getElementById('aiPause').classList.remove('show');
            document.getElementById('winnerMessage').classList.remove('show');
            document.getElementById('gameTimer').textContent = '00:00';

            // Clear boards
            playerBoard = Array(20).fill().map(() => Array(10).fill(0));
            aiBoard = Array(20).fill().map(() => Array(10).fill(0));
            drawBoard(playerBoard, 'playerGrid');
            drawBoard(aiBoard, 'aiGrid');
            document.getElementById('playerNext').innerHTML = '';
            document.getElementById('aiNext').innerHTML = '';

            // Reset scores
            playerScore = 0;
            playerLines = 0;
            playerLevel = 1;
            playerPieceCount = 0;
            aiScore = 0;
            aiLines = 0;
            aiLevel = 1;
            aiPieceCount = 0;

            updatePlayerDisplay();
            updateAIDisplay();
        }

        function endGame(winner) {
            gameActive = false;

            // Clear timers
            if (playerDropTimer) clearInterval(playerDropTimer);
            if (aiDropTimer) clearInterval(aiDropTimer);
            if (gameTimer) clearInterval(gameTimer);

            // Show winner message
            const winnerMessage = document.getElementById('winnerMessage');
            winnerMessage.classList.remove('player-win', 'ai-win');

            if (winner === 'player') {
                winnerMessage.textContent = `ðŸŽ‰ You Win! Final Score: ${playerScore}`;
                winnerMessage.classList.add('player-win');
            } else {
                winnerMessage.textContent = `ðŸ¤– AI Wins! Final Score: ${aiScore}`;
                winnerMessage.classList.add('ai-win');
            }

            winnerMessage.classList.add('show');

            // Reset UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        }

        function startGameTimer() {
            gameTimer = setInterval(() => {
                if (!gamePaused) {
                    const elapsed = Date.now() - gameStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('gameTimer').textContent =
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameActive || gamePaused) return;

            switch(e.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    movePiece(-1, 0);
                    e.preventDefault();
                    break;
                case 'd':
                case 'arrowright':
                    movePiece(1, 0);
                    e.preventDefault();
                    break;
                case 's':
                case 'arrowdown':
                    movePiece(0, 1);
                    e.preventDefault();
                    break;
                case 'w':
                case 'arrowup':
                case ' ':
                    rotatePiece();
                    e.preventDefault();
                    break;
                case 'q':
                    hardDrop();
                    e.preventDefault();
                    break;
                case 'p':
                    pauseGame();
                    e.preventDefault();
                    break;
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            createGrid('playerGrid');
            createGrid('aiGrid');
        });
    </script>
</body>
</html>